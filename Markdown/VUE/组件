## 组件

### 1.注册组件

**组件的使用分成三个步骤：**
创建组件构造器
注册组件
使用组件。
我们来看看通过代码如何注册组件

![1606293885868](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606293885868.png)

![1606293900646](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606293900646.png)

**查看运行结果：**
和直接使用一个div看起来并没有什么区别。
但是我们可以设想，如果很多地方都要显示这样的信息，我们是不是就可以直接使用<my-cpn></my-cpn>来完成呢？

### 2.全局组件和局部组件

**当我们通过调用Vue.component()注册组件时，组件的注册是全局的**

这意味着该组件可以在任意Vue示例下使用。

**如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件**

![1606294126230](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606294126230.png)

![1606294099094](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606294107717.png)

### 3.父子组件

![1606294477741](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606294477741.png)

### 4.注册组件语法糖

![1606294495715](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606294495715.png)

### 5.模板的分离写法

我们可以通过语法糖简化了Vue组件的注册过程，另外还有一个地方的写法比较麻烦，就是template模块写法。

如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰。

**Vue提供了两种方案来定义HTML模块内容：**

**p使用<script>标签**

**使用<template>标签**

![1606294408030](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606294408030.png)

### 6.组件数据的存放

组件自己的数据存放在哪里呢?

组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)

只是这个data属性必须是一个函数

而且这个函数返回一个对象，对象内部保存着数据

![1606294568752](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606294568752.png)

**为什么data在组件中必须是一个函数呢?**

首先，如果不是一个函数，Vue直接就会报错。

**其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。**

### 7.父子组件之间的通信

![1606294754577](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606294754577.png)

#### **父组件传子组件**

##### props的值有两种方式

方式一：**字符串数组**，数组中的字符串就是传递时的名称。

方式二：**对象**，对象可以设置传递时的类型，也可以设置默认值等。

我们先来看一个最简单的props传递：

![1606294881163](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606294881163.png)

##### props数据验证

在前面，我们的props选项是使用一个数组。
我们说过，除了数组之外，我们也可以使用对象，当需要对props进行类型等验证时，就需要对象写法了。
验证都支持哪些数据类型呢？
String   Number  Boolean  Array  Object  Date  Function  Symbol或使用函数：

![1606295258891](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606295258891.png)

当我们有自定义构造函数时，验证也支持自定义的类型

![1606295232868](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606295232868.png)

#### 子组件传父组件

**当子组件需要向父组件传递数据时，就要用到自定义事件了。**
**我们之前学习的v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。**

**自定义事件的流程：**
在子组件中，通过$emit()来触发事件。
在父组件中，通过v-on来监听子组件事件。
我们来看一个简单的例子：
我们之前做过一个两个按钮+1和-1，点击后修改counter。
我们整个操作的过程还是在子组件中完成，但是之后的展示交给父组件。
这样，我们就需要将子组件中的counter，传给父组件的某个属性，比如total。

![1606301222306](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606301222306.png)

### 8.父子组件的访问方式

#### 

#### 父组件访问子组件

1.$children    

![1606301590304](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606301590304.png)

**$children的缺陷：**
通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。
但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。
有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs



2. $refs

![1606301574978](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606301574978.png)

#### 子组件访问父组件

如果我们想在子组件中直接访问父组件，可以通过**$parent**
**注意事项：**
尽管在Vue开发中，我们允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做。
子组件应该尽量避免直接访问父组件的数据，因为这样耦合度太高了。
如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题。
另外，更不好做的是通过$parent直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护。

![1606301734987](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606301734987.png)

#### 父子组件的类名要设置的不一样

### <font color=red>9.编辑作用域</font>

官方对于编译的作用域解析比较简单，我们自己来通过一个例子来理解这个概念：
我们来考虑下面的代码是否最终是可以渲染出来的：
<my-cpn v-show="isShow"></my-cpn>中，我们使用了isShow属性。
isShow属性包含在组件中，也包含在Vue实例中。

![1606302005260](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606302005260.png)

答案：最终可以渲染出来，也就是使用的是Vue实例的属性。
**为什么呢？**
官方给出了一条准则：**父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。**
而**我们在使用<my-cpn v-show="isShow"></my-cpn>的时候，整个组件的使用过程是相当于在父组件中出现的。那么他的作用域就是父组件，使用的属性也是属于父组件的属性。因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。**

### 10. slot插槽

#### 为什么使用slot

**slot翻译为插槽：**
在生活中很多地方都有插槽，电脑的USB插槽，插板当中的电源插槽。
插槽的目的是让我们原来的设备具备更多的扩展性。
比如电脑的USB我们可以插入U盘、硬盘、手机、音响、键盘、鼠标等等。
**组件的插槽：**
组件的插槽也是为了让我们封装的组件更加具有扩展性。
让使用者可以决定组件内部的一些内容到底展示什么。
**栗子：移动网站中的导航栏。**
移动开发中，几乎每个页面都有导航栏。
导航栏我们必然会封装成一个插件，比如nav-bar组件。
一旦有了这个组件，我们就可以在多个页面中复用了。
但是，每个页面的导航是一样的吗？No，我以京东M站为例

![1606302847631](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606302847631.png)

#### 如何封装插槽

**如何去封装这类的组件呢？**
它们也很多区别，但是也有很多共性。
如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装。
但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字，等等。
**如何封装合适呢？抽取共性，保留不同。**
最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。
一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。
是搜索框，还是文字，还是菜单。由调用者自己来决定。
这就是为什么我们要学习组件中的插槽slot的原因。

#### slot基本使用

了解了为什么用slot，我们再来谈谈如何使用slot？
在子组件中，使用特殊的元素<slot>就可以为子组件开启一个插槽。
该插槽插入什么内容取决于父组件如何使用。
我们通过一个简单的例子，来给子组件定义一个插槽：
<slot>中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内容
有了这个插槽后，父组件如何使用呢？

![1606302940198](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606302940198.png)

#### 具名插槽

**当子组件的功能复杂时，子组件的插槽可能并非是一个。**
比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。
那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？
这个时候，我们就需要给插槽起一个名字
如何使用具名插槽呢？
非常简单，只要给slot元素一个name属性即可
<slot name='myslot'></slot>
我们来给出一个案例：
这里我们先不对导航组件做非常复杂的封装，先了解具名插槽的用法。

![1606302989307](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606302989307.png)

#### 作用域插槽

作用域插槽是slot一个比较难理解的点，而且官方文档说的又有点不清晰。
这里，我们用一句话对其做一个总结，然后我们在后续的案例中来体会：
**父组件替换插槽的标签，但是内容由子组件来提供。**

**我们先提一个需求：**
子组件中包括一组数据，比如：pLanguages: ['JavaScript', 'Python', 'Swift', 'Go', 'C++']
需要在多个界面进行展示：
某些界面是以水平方向一一展示的，
某些界面是以列表形式展示的，
某些界面直接展示一个数组
内容在子组件，希望父组件告诉我们如何展示，怎么办呢？
利用slot作用域插槽就可以了
**我们来看看子组件的定义：**

![1606303073637](C:\Users\Z\AppData\Roaming\Typora\typora-user-images\1606303073637.png)