## 1.面向对象的开发方式

面向对象的编程方式，优势在于：防止变量污染作用域，复用了属性名称等等，复用了方法。对象可以理解为命名空间。

```javascript
// 这里createPerson函数返回了对象，这种创建对象的方式也被称为  工厂模式（简单工厂模式，一种设计模式）
//可以通过函数创建对象
function createPerson(name,sex,age){
	//定义对象
    var obj = {}；
    //设置属性
    obj.name = name;
    obj.sex = sex;
    obj.age = age;
    
    //方法
    obj.getInfo = function(){
        // 这里的this指向对象，就是obj
        return '姓名'+this.name;
    }
    
    //返回对象
    return obj;
}
//创建对象
var p1 = createPerson('小兰'，'女',18);
var p2 = createPerson('小黑'，'男',19)；



```

#### <font color=red>闭包保护内部变量：</font>

```javascript
var obj ={
	a: 1,
	b: 2,
	demo: function(){
		return obj.a
	}
}
abc = obj;
obj = null;
/***
*此时使用abc调用demo会报错，因为obj为null,在demo中的obj.a出错
*/
abc.demo()
/***
*解决方法是使用闭包的思想，防止外界污染,如下。还有一种方法是能使用this的时候就使用this而非obj。
*var obj = (function(a,b){
*		var obj = {};
*		obj.a = a;
*		obj.b = b;
*		obj.demo = function(){
*			return obj.a;
*		};
*		return obj;
*	})(1,2);
*或者
*var obj = function(a,b){
*		var obj = {};
*		obj.a = a;
*		obj.b = b;
*		obj.demo = function(){
*			return obj.a;
*		};
*		return obj;
*	}
*var obj1 = obj(1,2)
*var obj2 = obj(3,4)
*





```

缓存外部this

```javascript
var obj = {
	....
	// 显示左侧图片
	showLeft: function(){
	    // 如果锁住了不执行
	    if(this.lock){
	        return;
	    }
	    this.lock = true;

	    this.id = (this.id+6)%7;
	    // 缓存外部this
	    var me = this;
	    // 先执行动画，再调节索引值
	    animate(this.ul,{left:-560*id},1000,function(){
	        console.log('success')
	        if(me.id === 0){
	            // 修改样式
	            css(me.ul,'left','-2800px');
	            me.id = 5;
	        }
	        me.lock = false;
	    })
	},
}
```

<font color='red'>缓存外部this在me中，修改回调函数, 这里是从demo中this的角度考虑的，让demo的this指向me</font>

```javascript
var obj ={
	...
	 //滚轮事件回调函数
     deal: function(e){
   		...
        this.showLeft()
      },
    // 定义启动
    init: function(){
        // 缓存外部this
        var me = this;
        //修改回调函数,这里是从demo中this的角度考虑的，让它的this指向me
        function demo(e){
        	me.deal(e);
        }
        // 给box绑定鼠标移入移出事件
        bindEvent(this.box,'mouseenter',function(){
        	//监听滚轮事件
        	bindEvent(document,'mousewheel',demo)
        });
        //鼠标移出
        bindEvent(this.box,'mouseleave',function(){
        	// 移除滚轮事件
        	removeEvent(document,'mousewheel',demo)
        });
    }
}
```

### 2.对象的分类

通过函数创建对象无法区分类别，为了区分类别我们要使用类。

```javascript
function createPerson(name, sex, age){
	//定义对象
	var obj = {};
	obj.name = name;
	obj.sex = sex;
	obj.age = age;
	//返回对象
	return obj;
}

function createDog(name, sex, age){
	//定义对象
	var obj = {};
	obj.name = name;
	obj.sex = sex;
	obj.age = age;
	//返回对象
	return obj;
}

//创建。这里创建的p和d是无法区分类别的,console.log(p)与console.log(d)输出的都是object{...},object{...},其中{...}都是些一样的属性，我们在别处无法判断哪个是由createPerson创建的，哪个是由createDog创建的。
var p = createPerson('小白', '男', 20)
var d = createDog('京巴', '公', 5)
console.log(p,d)//输出是object{...},object{...},其中{...}都是些一样的属性

```

##### 构造函数

构造函数与普通函数在定义方式上没有不用，只不过构造函数的首字母要大写(这并不是语法要求）<br>

构造函数必须使用new关键字进行调用<br>

<font color='red'>通过构造函数可以创建一类对象，该构造函数就称之为类，创建的对象称之为该类的实例化对象。</font>

```javascript
function Person(){
    
}
function Dog(){
    
}
var p = new Person();
var d = new Dog();
console.log(p,d);//输出Person{...},Dog{...}
```



<font color=red>与普通函数比较</font><br>

&emsp;&emsp;目的：&emsp;&emsp;普通函数：实现某一类功能；&emsp;&emsp;&emsp;构造函数：为了创建对象<br>

&emsp;&emsp;调用方式：&emsp;普通函数：直接调用；&emsp;&emsp;&emsp;构造函数：使用new进行调用<br>

构造函数执行时候的四个步骤：<br>

1.开辟一个新的内存空间<br>

2.改变this指向<br>

```javascript
//普通函数
function person(){
    console.log(this)
}
person()//输出结果为 Window
//构造函数
function Person(){
    console.log(this)
}
new Person()//输出结果为Person
```



3.执行函数中的代码，为this赋值<br>

```javascript
//构造函数
function Person(name, sex, age){
    this.name = name;
    this.sex = sex;
    this.age = age;
}
```



4.返回this<br>

```javascript
//构造函数
function Person(name, sex, age){
    this.name = name;
    this.sex = sex;
    this.age = age;
    //返回其他数据
    //如果是值类型没有影响，(数字，字符串，布尔值，undefined,null，对象)
    //例如：return 100；  return 'hello';  return true;  return undefined; return nulll。在var p = new Person（...）时，p仍旧是Person不受其他的影响。    
    //返回对象，实例对象会被替代
    //例如： return {'color':red}, return [1,2,3],  return function demo(){}。在var p = new Person（...）时，p仍旧是会受其他的影响。但可以返回this。
}
```

### 3.数组塌陷

删除数组中某一位置的值后，后面的值会自动往前移动。数组塌陷实际上就是将一摞砖中的其中一块砖给抽掉，你会发现被抽掉的上部分砖会坍塌下来来填补被抽掉的空缺，在这里被抽掉的砖头你可以理解为删掉的数组元素。

```javascript
var arr = [0,1,2,3,4,5,6,8,9];
移除其中值为6的那个元素，arr变成[0,1,2,3,4,5,7,8,9]
```

```javascript
//遍历数组
for(var i=0; i<arr.length; i++){
    console.log(i, arr[i], arr, arr.length)
    //删除成员6
    if(arr[i]===6){
        //删除了成员，数组的长度就变小了
        arr.splice(i,1);
    }
}
```

<font color=red>处理数组塌陷问题：</font><br>

方法一，既然数组整体往前挪了一个单位，那我们就想办法给他补回来：

```javascript
//遍历数组
for(var i=0; i<arr.length; i++){
    console.log(i, arr[i], arr, arr.length)
    //删除成员6
    if(arr[i]===6){
        //删除了成员，数组的长度就变小了
        arr.splice(i,1);
        //长度改变之后，要纠正索引值
        i--;
    }
}
```

方法二，既然从下面拿会塌陷，那咱们可以从上面开始取，也就是倒着循环遍历删除：

```javascript
//遍历数组
for(var i=arr.length;i>=0; i--){
    console.log(i, arr[i], arr, arr.length)
    //删除成员6
    if(arr[i]===6){
        //删除了成员，数组的长度就变小了
        arr.splice(i,1);
    }
}
```

### 4.原型

<font color=red>在构造函数中，为this添加的方法，会让每一个实例单独存储一份，即使方法的实现时一模一样的，函数是不同的。但没有必要让两个函数是不同的。</font><br>

```javascript
function Person(name, sex, age){
    this.name = name;
    this.sex = sex;
    this.age = age;
    this.getName = function(){
        console.log(this.name)
    }
}
var p1 = new Person(...);
var p2 = new Person(...);
console.log(p1.name===p2.name, p1.sex===p2.sex, p1.age===p2.age, p1.getName===p2.getName)//结果全是 false
```

解决方案一: 将函数定义在外面。但问题是将方法放在全局了，就会污染作用域。

```javascript
function Person(name, sex, age){
    this.name = name;
    this.sex = sex;
    this.age = age;
    this.getName = getName;
}
function getName(){
	console.log(this.name)
}
var p1 = new Person(...);
var p2 = new Person(...);
console.log(p1.getName===p2.getName)//结果是 true
```

解决方案二：可以将全局的方法，放在对象中存储，减少全局变量（对象起到命名空间的作用）。

```javascript
function Person(name, sex, age){
    this.name = name;
    this.sex = sex;
    this.age = age;
    this.getName = obj.getName;
}

var obj = {
	getName: function(){
		console.log(this.name)
	}
}
var p1 = new Person(...);
var p2 = new Person(...);
console.log(p1.getName===p2.getName)//结果是 true
```

解决方案三：将obj对象作为属性存储在构造函数上,但这样会使构造函数内部与函数名耦合在一起，会出现。<br>

```javascript
function Person(name, sex, age){
    this.name = name;
    this.sex = sex;
    this.age = age;
    //构造函数内部与函数名耦合在一起,很不妙
    this.getName = Person.obj.getName;
}
Person.obj.getName =  function(){
		console.log(this.name)
	}
var ips = Person;
Person = null;
//无法创建，会报错
var p1 = new ips(...);
//无法创建，会报错
var p1 = new ips(...);
```



##### <font color = red> js为构造函数提供了原型对象，__prototype__。这是函数天生的，它是一个对象，可以存储数据和方法。</font><br>

原型对于普通函数来说没有意义,但是对于构造函数来说<br>&emsp;&emsp;每一个构造函数的实例化对象都可以访问原型中的属性和方法。<br>&emsp;&emsp;每一个构造函数都有一个隐含的属性指向该原型对象，通过 \_\_proto\_\_  属性来访问原型对象。<br>原型对象是一个公共区域，所有的实例化都可以直接访问。<br><font color=red>在创建构造函数的时候我们可以将所有的方法都放在原型对象中，这样方法就不会污染全局作用域，每一个实例化对象都可以访问。<br>每一个实例化对象访问一个属性或者方法的时候，会从自身查找，有的话会使用自身的，没有的话会去原型中查找。<br>原型的作用是为实例共享属性和方法。</font>

```javascript
function Person(name, sex, age){
    this.name = name;
    this.sex = sex;
    this.age = age;
}
Person.prototype.getName =  function(){
		console.log(this.name)
	}

//var p1 = new Person(...);
//var p2 = new Person(...);
//console.log(p1.getName===p2.getName)//结果是 true
var ips = Person;
Person = null;
//都可以创建
var p1 = new ips(...);
var p1 = new ips(...);
console.log(p1.getName===p2.getName)//结果是 true
```

**构造函数特点：**

1.<font color=red>每一个实例化对象访问一个属性或者方法的时候，会从自身查找，有的话会使用自身的，没有的话会去原型中查找。<br></font>

```javascript
function Person(name, sex, age){
    this.name = name;
    this.sex = sex;
    this.age = age;
    //定义同名方法
    this.getName = function(){
        console.log(this.name)
    }
}
Person.prototype.getName =  function(){
		console.log('姓名：',this.name)
	}
Person.prototype.msg = 'hh'

var p1 = new ips('小白'，'男',20);
p1.getName();//输出： 小白   
```

2.构造函数的constructor属性代表构造函数。类通过prototype找到原型对象，原型对象通过constructor找到类。

```javascript
function Person(name, sex, age){
    ...
}
var p1 = new Person('小白'，'男',20);
console.log(p1.constructor)//结果： Person构造函数
```

3. for in循环，可以将原型中的数据遍历处理。

4. hasOwnProperty方法，如果是自身的返回true，如果是原型的返回false。

   ```javascript
   function Person(name, sex, age){
       ...
   }
   var p1 = new Person('小白'，'男',20);
   for (var key in p1){
       console.log(p1.hasOwnProperty(key))
   }
   ```

   5.instanceof 关键字用于判定某一对象是否是在一个构造函数的实例。会查询整个原型链。

   ```javascript
   function Person(name, sex, age){
       ...
   }
   var p1 = new Person('小白'，'男',20);
   console.log(p1 instanceof Persion);//判断p1是否Persion类的实例。返回true
   console.log(p1 instanceof Object);//返回true（原型链）。 
   ```

   6.原型链，原型对象也是对象，对象有原型对象，所以原型对象也有原型对象。

   ##### <font>数据在查找的时候，会在当前实例对象上查找，当前实例对象没有，去原型对象上查找，原型对象没有，回去原型对象的原型对象上查找...一直查到原型对象的终点。如果此时还没有找到那就说明该数据是不存在的。那么这种查找过程就是原型链，与作用域类似。</font>

<font color=red>双下划线都是内置的属性，不建议我们访问。构造函数也是对象，因此它的原型对象就是函数。</font>

### 5.原型链

<font>数据在查找的时候，会在当前实例对象上查找，当前实例对象没有，去原型对象上查找，原型对象没有，回去原型对象的原型对象上查找...一直查到原型对象的终点。如果此时还没有找到那就说明该数据是不存在的。那么这种查找过程就是原型链，与作用域类似。</font>

![1603974473016](C:\Users\yangqian\AppData\Roaming\Typora\typora-user-images\1603974473016.png)

```javascript
function Foo(),function Object(),function Function()类，它们都可以使用prototype属性找到它们的原型类，它们的原型类也都可以通过constructor属性找到它们对应的类。
在图中f1,f2,o1,o2以及function Foo(),function Object(),function Function()构造函数都是对象，它们都可以使用__proto__属性找到它们对应的原型类。
```

### 6安全类

一切数据都可以看成是对象，是对象都有与之对应的类。<font color=red>(换句话说就是一切数据都可以使用类来创建。)</font><br>

例如: 数组对应的类时Array，对象对应的类时Object。

```javascript
//创建数组的三种方式：
var arr = [1,2,3];//字面量
//构造函数和工厂方式不是很常用，因为它们对参数做了重载。（传递的参数个数的不同，以及类型的不同，得到的结果不同（执行的逻辑不同，具体是利用函数的类数组对象argument实现重载））
//例如：由于模式重载new Array(3)表示长度为3的空数组，new Array('3')表示元素为'3'的数组, new Array(2,3)表示元素为2,3的数组。Array(3)，Array('3')，Array(2,3)效果都是一样的，因为Array构造函数内部也是这样实现的。
var arr2 = new Array(3,4,5);//构造函数
var arr3 = Array(3,4,5);//工厂方法。
console.log(arr,arr2,arr3)
```

```javascript
//创建对象的三种方式
//字面量
var obj1 = { color: 'red'};//字面量
var obj2 = new Object({color:'green'})//构造函数
var obj3 = Object({color:'pink'})//工厂方法
console.log(obj1,obj2,obj3)
```

<font color=red>安全类要解决的问题：</font>

```javascript
var age = 50;
//创建类
function People(name,age){
    console.log(this);
    this.name = name;
    this.age = age;
}
//创建对象
var p1 = new People('张三',20);

//没有创建出对象，把构造函数当作普通函数去使用了
//this赋值被添加到全局了(即People中的this指向了window，污染了全局作用域)
var p2 = People('李四',30);
console.log(age);//此时，由于受上一行代码的影响，这里输出的age为30
console.log(p1,p2)
```

<font color=red>安全类，在定义的构造函数内部判断this是否是该类的实例，是的话，直接实例，不是的话重新实例并返回</font>

```javascript
var age = 50;
//安全类，在定义的构造函数内部判断this是否是该类的实例，是的话，直接实例，不是的话重新实例并返回
//  Array内部也是类似实现的。
function People(name,age){
    if(this instanceof People){
        //直接赋值                                                                         
        this.name = name;
        this.age = age;
    }else {
        return new People(name,age)
    }
}
//创建对象
var p1 = new People('张三',20);
//this不再污染全局作用域
var p2 = People('李四',30);
console.log(age);//此时，这里输出的age为50
console.log(p1,p2);
```

### 7.内置构造函数

内置构造函数的分类：<br>

&emsp;&emsp;ECMAScript核心语法也支持一些内置构造函数（不是我们创建的，是js语言天生存在的，例如 Image）：<br>

&emsp;&emsp;Object  Array  Function   String   Number   Boolean   RegExp   Error   Date

(RegExp为正则表达式的构造函数，当然还有很多其他的内置构造函数这里只列举了一部分。)

```javascript
//Object,Array在前面小节已经讲过了，这里不再赘述。

//创建函数的三种方式
//函数定义式
function demo1(){
    console.log('demo1');
}
//函数表达式
var demo2 = function(){
    console.log('demo2')
}
//构造函数式；
//前面的参数表示函数的参数，最后一个参数表示函数体。当然也可以设置返回值
var demo3 = new Function('a','b','return a + b');
//让字符值作为语句去执行的第二种方式
eval('console.log("hello ickt")')
eval('var num = 100')
console.log(num)
/***
*new Function与eval的区别，
*	new Function定义的变量式在函数体内部定义的，是局部变量
*	eval字符串中定义的变量，由于在全局作用域中执行，因此会存储在全局，污染全局作用域
*/
demo1();
demo2();
var result = demo3(10,20);
console.log(result);
```

```

```

